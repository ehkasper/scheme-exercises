#lang racket

;; exercise 1
(define (sumsq N)
  (if (= 1 N) 1
      (+ (* N N) (sumsq(- N 1)))
  )
)

;;(sumsq 4)
;;(sumsq 5)
;;(sumsq 6)
;; end of exercise 1


;; exercise 2
(define (trim N L)
  (if (zero? N) L
    (trim (- N 1) (reverse (cdr (reverse L))))
  )
)

;;(trim 4 '(1 2 3 4 5 6))
;;(trim 2 '((1 2 (3) 4 5 (6)) (7 8) (9 8) (7)))
;; end of exercise 2

;; exercise 3


(define (mycount A X)
  (cond ((eq? A X) 1)
        ((or (null? X) (not (list? X))) 0)
        (else (+ (mycount A (cdr X)) (mycount A (car X))))
  )
)

;(mycount 1 '(a 1 b 2 c 1)) ;; => 2
;(mycount 'a '(a (b (a c) a) d)) ;; => 3
;(mycount 'a 'b) ;; => 0
;(mycount 'a 'a) ;; => 1
;(mycount 'a '()) ;; => 0
;(mycount 3 '((((4))))) ;; => 0
;(mycount 3 '((((3))))) ;; => 1
;; end of exercise 3

; exercise 4

; a) slow fibonacci

(define (slowfib N)
  (cond ((equal? N 0) 0)
        ((equal? N 1) 1)
        (else (+ (slowfib (- N 1)) (slowfib (- N 2))))
))

;(slowfib 10) ; <- takes a long time

; b) fast fibonacci

; iterate through the list and tests whether the function has reached the last element or not.
(define (fastfiblist beginning L last)
   (let ((nList (cons (+ (car L) (car (cdr L))) L)))
        (if (= beginning last) nList
            (fastfiblist (+ beginning 1) nList last))))

; returns the last number generated by the loop
(define (fastfib N)
  (cond ((= N 0) '(0))
        ((= N 1) '(0 1))
        (else (car (fastfiblist 2 '(1 0) N)))))


; exercise 5

(define (leftmost L)
    (cond ((or (number? L) (null? L)) '())
          ((symbol? L) L)
          ((symbol? (car L)) (car L))
          ((list? (car L))
            ; assigning a candidate and testing if it is the left most element.
            ; continues the iteration if it isn't
            (let ((candidate (leftmost (car L))))
               (if (empty? candidate) (leftmost (cdr L))
                     candidate)))
          (else (leftmost (cdr L)))))


; exercise 6
(define (myreplace A B X)
  (cond ((null? X) X)
        ((equal? A X) B)
        ((list? X)
         ; doing the recursivity and replacing the car (if necessary) and the cdr
         (cons (myreplace A B (car X)) (myreplace A B (cdr X)))
        )
        (else X)))


; exercise 7

(define (mymap P F L)
  (cond ((null? L) '()) ; if null returns empty list
        ((P (car L)) (cons (F (car L)) (mymap P F (cdr L)))) ;applies to the car
        (else (cons (car L) (mymap P F (cdr L)))))) ; cons of the car and the rest of the list
